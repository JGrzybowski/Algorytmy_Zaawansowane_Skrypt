\section{Programowanie Dynamiczne}
Czasami, gdy próbujemy rozwiązać problem formułą rekurencyjną otrzymujemy bardzo wolny algorytm o złożoności wykładniczej. Najczęściej do takich sytuacji dochodzi, gdy liczymy te same rzeczy wielokrotnie.

\subsection{Liczby Fibonacciego}
$$ F(n) = \begin{cases}
	F(0) = F(1) = 1 \\
	F(n) = F(n-1) + F(n-2)
\end{cases}$$
\subsubsection{Implementacja rekurencyjna} 
\begin{lstlisting}[caption={FIBR(n) - rekurencyjny algorytm liczący n-tą liczbę Fibonacciego}]
if $n \leq 1$ return 1
return FIBR(n-1) + FIBR(n-2)
\end{lstlisting}
Ilość wywołań dla FIBR(5):
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c}
						$n$	& 0 & 1 & 2 & 3 & 4 & 5 \\ \hline 
Ile razy liczymy $FIBR(n)$ 	& 3 & 5 & 3 & 2 & 1 & 1 \\ 
\end{tabular} 
\end{center}

Niech $S(n)$ będzie ilością dodawań w $FIBR(n)$
$$ \begin{cases}
	S(0) = S(1) = 0 \\
	S(n) = S(n-1) + S(n-2) + 1 $ dla $ n \geq 2
\end{cases}$$

niech 
$$f(n) = S(n) + 1$$
$$f(0) = f(1) = 1$$
$$f(n) = S(n) + 1 = S(n-1) + S(n-2) + 1 + 1 = f(n-1) + f(n-2)$$
$$f(n) = F(n)$$
$f(n) = \Theta((\frac{\sqrt{5}+1}{2})^n) = \Omega(1.61^n)$ więc również $S(n) = \Theta((\frac{\sqrt{5}+1}{2})^n) $ Zatem algorytm FIBR(n) ma złożoność wykładniczą.

\subsubsection{Implementacja wykorzystująca programowanie dynamiczne}
\begin{lstlisting}[caption={FIBD(n) - dynamiczny algorytm liczący n-tą liczbę Fibonacciego}]
if $n \leq 1$ return 1
$F[0]$ <- $F[1]$ <- 1
for $i$ <- 2 to $n$
	$F[i]$ <- $F[n-1] + F[n-2]$
return $F[n]$
\end{lstlisting}
Ilość dodawań wynosi $n-1$ zatem złożoność algorytmu FIBD(n) wynosi $\Theta(n)$.

